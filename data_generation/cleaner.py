# -*- coding: utf-8 -*-
"""
Created on Fri Jan 24 19:46:57 2020

@author: Tim-Laptop

This file is for cleaning the raw data generated by the trackmouse.py record()
function, the word 'batch' when mentioned in the comments in this file means
all of the data entries correspoding to one move event: ie movement between two
mouse clicks
"""

import csv


# global constants
SOURCE_CSV = "../data/recorded_cursor_data.csv"
DEST_CSV = "../data/cleaned_cursor_data.csv"
BUFFER_SIZE = 4096


class Cleaner:
    
    
    def __init__(self):
        self.current_line = 0
        self.current_batch_num = 1
        self.last_seek_pos = 0
        self.batch_count = get_batch_count()
        self.n_final = get_n_final()
        
        
    def clean(self, raw_data):
        ''' the clean function takes the points from the raw data, which is
        recorded at non-uniform time intervals and calculates "fake data"
        where points would be if their position was recorded at exactly 8 ms
        intervals
        '''
        t_init = raw_data[0][0][2]
        t_final = sum([entry[2] for entry in raw_data])
        t_net = t_final - t_initial
        
        #define the two points on either side of our hypothetical piont
        p1 = raw_data[0]
        p2 = raw_data[1]
        
        #create vectors for the x and y variables with respect to time
        xline = [i[0], i[2] for i in [p1, p2]]
        yline = [i[1], i[2] for i in [p1, p2]]
        clean_data = []
        
        #populate clean data list by fitting raw data to 8 ms intervals
        for t in  [i*8 for i in range(t_net//8)]:
            p2 = raw_data[p1.index() + 1]
            if t >= p2[2]:
                xline = create_line(p1, p2, 0)
                yline = creat_line(p1, p2, 1)
                p1 = raw_data [p1.index() + 1]
                x_intercept = find_intercept(xline, t)
                y_intercept = find_intercept(yline, t)
                clean_data.append([x_intercept, y_intercept, t])
        return clean_data
            
        
    
    def read_next_block(self):
        ''' open the csv file, read in all the data entries for one movement,
        all the coords between two click events, and close the file when you
        reach the next batch ie movement between click events'''
        batch_data = []
        with open(SOURCE_CSV, 'r', BUFFER_SIZE) as f:
            f.seek(self.last_seek_pos)
            while self.get_batch_num(f) == self.current_batch_num:
                batch_data.append([int(i) if i.isdigit() else i for i in
                                   f.readline().rstrip('\n').split(',')])
                for entry in batch_data:
                    print(entry)
                self.current_batch_num += 1
                self.last_seek_pos = f.tell()
        return batch_data
                
    
    def write_next_block(self, clean_data):
        ''' append the cleaned data to a cleaned_data csv file, one batch at
        a time'''
        with open(DEST_CSV, 'a', BUFFER_SIZE) as f:
            writer = csv.writer(f)
            writer.writerows(clean_data)
            
    
    def get_batch_num(self, file, seek_pos):
        ''' find the current data batch based on seek location in a file '''
        file.seek(seek_pos)
        this_row = csv.reader(file).__next__()
        file.seek(seek_pos)
        return this_row[0]
      
    def get_n_final(self):
        return reversed(list(csv.reader(f)))[0][3]
    
    def get_batch_count(self):
        ''' find the total number of batches in the source csv file '''
        with open(SOURCE_CSV, 'r') as file:
            return reversed(list(csv.reader(file)))[0][0]
    
        '''
        except TypeError:
            print('type error')
            for letter in file.readline():
                if n := letter.isdigit():
                    return int(n)
            return None
        except IndexError:
            print('index error, [0][0] does not exist :(')
        '''

    '''
    def get_line_offsets(self):
        with open(SOURCE_CSV, 'rb', BUFFER_SIZE) as file:
            line_offsets = []
            offset = 0
            for line in file:
                line_offsets.append(offset)
                offset += len(line)
        return line_offsets '''
    
c = Cleaner()
c.clean()

        